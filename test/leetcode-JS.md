LeetCode OJ 题解
================


LeetCode OJ 是为与写代码有关的技术工作面试者设计的训练平台。

LeetCode OJ:[http://oj.leetcode.com/](http://oj.leetcode.com/)

默认题目顺序为题目添加时间倒叙，本文题解顺序与OJ题目顺序一致（OJ会更新，至少目前一致。。。），目前共151题。

Made By：[CSGrandeur](http://www.cnblogs.com/CSGrandeur/p/3520937.html)


【注意】 这里是 JavaScript版 实现


//
// LeetCode List
//


Num   Add Date    Title

151.   2014/03/05  Reverse Words in a String
150.   2013/11/27  Evaluate Reverse Polish Notation
149.   2013/11/22  Max Points on a Line
148.   2013/11/16  Sort List
147.   2013/11/12  Insertion Sort List
146.   2013/11/09  LRU Cache
145.   2013/11/07  Binary Tree Postorder Traversal
144.   2013/11/05  Binary Tree Preorder Traversal
143.   2013/11/02  Reorder List
142.   2013/10/30  Linked List Cycle II
141.   2013/10/28  Linked List Cycle
140.   2013/10/05  Word Break II
139.   2013/10/04  Word Break
138.   2013/10/03  Copy List with Random Pointer
137.   2013/10/02  Single Number II
136.   2013/10/01  Single Number
135.   2013/09/30  Candy
134.   2013/09/28  Gas Station
133.   2013/09/24  Clone Graph
132.   2013/02/28  Palindrome Partitioning II
131.   2013/02/27  Palindrome Partitioning
130.   2013/02/21  Surrounded Regions
129.   2013/02/18  Sum Root to Leaf Numbers
128.   2013/02/13  Longest Consecutive Sequence
127.   2013/02/10  Word Ladder II
126.   2013/02/10  Word Ladder
125.   2013/01/12  Valid Palindrome
124.   2012/11/07  Binary Tree Maximum Path Sum
123.   2012/11/06  Best Time to Buy and Sell Stock III
122.   2012/10/30  Best Time to Buy and Sell Stock II
121.   2012/10/30  Best Time to Buy and Sell Stock
120.   2012/10/29  Triangle
119.   2012/10/28  Pascal's Triangle II
118.   2012/10/28  Pascal's Triangle
117.   2012/10/28  Populating Next Right Pointers in Each Node II
116.   2012/10/28  Populating Next Right Pointers in Each Node
115.   2012/10/18  Distinct Subsequences
114.   2012/10/14  Flatten Binary Tree to Linked List
113.   2012/10/14  Path Sum II
112.   2012/10/13  Path Sum
111.   2012/10/09  Minimum Depth of Binary Tree
110.   2012/10/08  Balanced Binary Tree
109.   2012/10/02  Convert Sorted List to Binary Search Tree
108.   2012/10/02  Convert Sorted Array to Binary Search Tree
107.   2012/10/01  Binary Tree Level Order Traversal II
106.   2012/09/30  Construct Binary Tree from Inorder and Postorder Traversal
105.   2012/09/30  Construct Binary Tree from Preorder and Inorder Traversal
104.   2012/09/29  Maximum Depth of Binary Tree
103.   2012/09/28  Binary Tree Zigzag Level Order Traversal
102.   2012/09/28  Binary Tree Level Order Traversal
101.   2012/09/23  Symmetric Tree
100.   2012/09/03  Same Tree
99.    2012/09/01  Recover Binary Search Tree
98.    2012/08/31  Validate Binary Search Tree
97.    2012/08/30  Interleaving String
96.    2012/08/27  Unique Binary Search Trees II
95.    2012/08/27  Unique Binary Search Trees
94.    2012/08/27  Binary Tree Inorder Traversal
93.    2012/08/07  Restore IP Addresses
92.    2012/06/27  Reverse Linked List II
91.    2012/06/25  Subsets II
90.    2012/06/25  Decode Ways
89.    2012/05/20  Gray Code
88.    2012/05/20  Merge Sorted Array
87.    2012/04/30  Scramble String
86.    2012/04/30  Partition List
85.    2012/04/23  Maximal Rectangle
84.    2012/04/22  Largest Rectangle in Histogram
83.    2012/04/22  Remove Duplicates from Sorted List II
82.    2012/04/22  Remove Duplicates from Sorted List
81.    2012/04/19  Search in Rotated Sorted Array II
80.    2012/04/19  Remove Duplicates from Sorted Array II
79.    2012/04/18  Word Search
78.    2012/04/18  Subsets
77.    2012/04/18  Combinations
76.    2012/04/15  Minimum Window Substring
75.    2012/04/08  Sort Colors
74.    2012/04/06  Search a 2D Matrix
73.    2012/04/05  Set Matrix Zeroes
72.    2012/04/04  Edit Distance
71.    2012/04/03  Simplify Path
70.    2012/04/03  Climbing Stairs
69.    2012/04/03  Sqrt(x)
68.    2012/04/03  Text Justification
67.    2012/04/02  Plus One
66.    2012/04/02  Valid Number
65.    2012/04/02  Add Binary
64.    2012/03/30  Merge Two Sorted Lists
63.    2012/03/28  Minimum Path Sum
62.    2012/03/28  Unique Paths II
61.    2012/03/28  Unique Paths
60.    2012/03/27  Rotate List
59.    2012/03/27  Permutation Sequence
58.    2012/03/27  Spiral Matrix II
57.    2012/03/27  Length of Last Word
56.    2012/03/27  Insert Interval
55.    2012/03/26  Merge Intervals
54.    2012/03/24  Jump Game
53.    2012/03/24  Spiral Matrix
52.    2012/03/21  Maximum Subarray
51.    2012/03/20  N-Queens II
50.    2012/03/19  N-Queens
49.    2012/03/19  Pow(x, n)
48.    2012/03/19  Anagrams
47.    2012/03/17  Rotate Image
46.    2012/03/16  Permutations II
45.    2012/03/16  Permutations
44.    2012/03/16  Jump Game II
43.    2012/03/15  Wildcard Matching
42.    2012/03/12  Multiply Strings
41.    2012/03/10  Trapping Rain Water
40.    2012/03/08  First Missing Positive
39.    2012/03/06  Combination Sum II
38.    2012/03/06  Combination Sum
37.    2012/03/05  Count and Say
36.    2012/03/04  Sudoku Solver
35.    2012/03/03  Valid Sudoku
34.    2012/03/03  Search Insert Position
33.    2012/03/02  Search for a Range
32.    2012/03/02  Search in Rotated Sorted Array
31.    2012/02/29  Longest Valid Parentheses
30.    2012/02/25  Next Permutation
29.    2012/02/23  Substring with Concatenation of All Words
28.    2012/02/18  Divide Two Integers
27.    2012/02/18  Implement strStr()
26.    2012/02/16  Remove Element
25.    2012/02/16  Remove Duplicates from Sorted Array
24.    2012/02/15  Reverse Nodes in k-Group
23.    2012/02/14  Swap Nodes in Pairs
22.    2012/02/13  Merge k Sorted Lists
21.    2012/02/12  Generate Parentheses
20.    2012/01/30  Valid Parentheses
19.    2012/01/27  Remove Nth Node From End of List
18.    2012/01/26  Letter Combinations of a Phone Number
17.    2012/01/26  4Sum
16.    2012/01/18  3Sum Closest
15.    2012/01/17  3Sum
14.    2012/01/17  Longest Common Prefix
13.    2012/01/15  Roman to Integer
12.    2012/01/15  Integer to Roman
11.    2012/01/08  Container With Most Water
10.    2012/01/08  Regular Expression Matching
9.     2012/01/04  Palindrome Number
8.     2011/12/26  String to Integer (atoi)
7.     2011/12/25  Reverse Integer
6.     2011/12/05  ZigZag Conversion
5.     2011/11/11  Longest Palindromic Substring
4.     2011/11/01  Add Two Numbers
3.     2011/05/15  Longest Substring Without Repeating Characters
2.     2011/03/27  Median of Two Sorted Arrays
1.     2011/03/13  Two Sum






## 1. Reverse Words in a String

/* intro 反序输出单词

Given an input string, reverse the string word by word.

For example,
Given s = "the sky is blue",
return "blue is sky the".

Clarification:

What constitutes a word?
A sequence of non-space characters constitutes a word.

Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.

How about multiple spaces between two words?
Reduce them to a single space in the reversed string.

**/

    //方法1   (使用了一些现成的方法)
    function reverseWords(str){
        //var arr = str.replace(/(^\s+)|(\s+$)/g,"").split(' ');
        var arr = str.match(/\S+/g);
        return arr.reverse().join(' ');
    }
    var str = "the sky is blue ";
    reverseWords(str);

    //方法2   (如果不使用系统分割等方法呢)
    //先翻转整个字符串，然后从前往后一个单词一个单词地再翻转一次，同时去除多余空格，等于是扫描两遍，O(n)。
    function reverseWords(str){
        var arr = '';
    }
    var s = "the sky is blue";
    reverseWords(s);



## 2. Evaluate Reverse Polish Notation

/* intro 计算逆波兰式

Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Some examples:

    ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
    ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6

**/

    //方法1
    function evalRPN(tokens){
        var returnValue = 0,
            operators = "+-*/",
            numsStack = [];
        for(i=0,len = tokens.length;i<len;i++){
            var t = tokens[i];
            if(operators.indexOf(t)==-1){
                //当前非运算符，则存入，否则弹出两个数字做运算并存入
                numsStack.push(parseInt(t,10));
                //console.log(t);
            }else{
                var a = parseInt(numsStack.pop(),10),
                    b = parseInt(numsStack.pop(),10);
                switch(t){
                    case "+":
                        numsStack.push(a+b);
                        break;
                    case "-":
                        numsStack.push(b-a);
                        break;
                    case "*":
                        numsStack.push(a*b);
                        break;
                    case "/":
                        if (a != 0){
                            numsStack.push(b/a);
                        }else{
                            console.log("除零错误");
                            return;
                        }
                        break;
                }
                console.log(numsStack);
            }
        }

        returnValue = parseInt(numsStack.pop(),10);
        return returnValue;
    }
    var input = ["2", "1", "+", "3", "*"];
    var input = ["3", "4", "2", "*", "+" ,"6", "-"];//3+4*2-6
    var input = ["3", "2", "6", "5", "-" ,"*", "+"];//3+4*2-6
    var output = evalRPN(input);
    console.log(output);




## 3. 



